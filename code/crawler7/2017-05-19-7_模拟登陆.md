---
layout: post
categories: [crawler]
title: 模拟登陆
date: 2117-05-20
author: TTyb
desc: "7.模拟登陆"
showdate: 2017-05-20
---

前面学习了如何在 `get` 的时候想服务器发送多变的请求数据，从而达到搜索的效果，而实际上 `搜索是简单的登陆` ！所以本文将要介绍如何向百度服务器发送 `post` 数据，从而达到模拟登陆百度的效果。

>1. 首先打开 `firefox` 浏览器，清除网页所有的历史纪录，这是为了防止以前的 `Cookie` 影响服务器返回的数据。
>2. `F12` 打开 `firebug` ，进入百度首页，点击 **网络** -> **清除** ,这是为了删掉打开百度首页而弹出来的 `html`，方便后面的查找 `html` 数据。
>3. 点击登陆按钮，依次填写账号、密码、验证码，点击 **登陆** ，在 `firebug` 中点击 `保持` ，这是为了防止登陆成功后，登陆表单的 `html` 被清除。

在 `firebug` 中，找到如下一行 `POST?login` ：

<img  src="/img/crawler7/result1.jpg"/>

点击前面的 `+` 号 -> `post` ，可以看到提交的表单，这个就是点击登陆后，网页向百度服务器后端发送的 **登陆请求表单**，表单中包含了 **账号**、**密码**、**其他** 等信息：

<img  src="/img/crawler7/result2.jpg"/>

如果百度后台认为此 **登陆表单请求** 是正确的后，会在 **头信息** -> **响应头信息** 中返回一个 `Set-Cookie` 。当我们登陆成功后，关闭浏览器，下次再打开浏览器的时候发现百度还是处于一种登陆的状态，这就是和 `Cookie` 有关。在百度登陆成功后会返回一个 `Cookie` 储存到浏览器中，下次再打开百度的时候，浏览器中的 **头信息** -> **请求头信息** 中会携带一个 `Cookie` ，这个 `Cookie` 就是百度服务器判断你以前是否登陆过百度。而这个 `Cooike` 就是 `Set-Cookie` 加工而来的！那么重点来了，如果要用代码模拟登陆百度，应该要具备以下几个步骤：

>1. 构造请求表单
>2. 请求成功后获取 `Cookie` (这个 `Cookie` 并非 `Set-Cookie`)
>3. 在请求头部 `header` 中携带这个 `Cookie` ，就可以以登陆过后的身份访问百度

原理讲清楚了，那么下面开始实践！

### 构造请求表单

在上面的 `POST?login` 中发现百度的请求表单还是挺多的，那么如何表单中判断哪些是变化的那些事不变的？再一次清空 `firefox` 的全部历史纪录，清除 `firebug` 的 `html` ，重新在百度首页点击 **登陆** ，填写 **账号**、**错误的密码**、**验证码**，复制 `POST?login` 中的 `post` 信息下来，然后重复前面的步骤，就可以得到很多 `post` 信息，拿出来对比就可以知道哪些信息是变化的了。这里要解释一下为什么要填写 **错误的密码**，因为密码错误啦，登陆框就会一直都在啊，免去了清除 **全部历史纪录** 和清除 `html` 的步骤。最后对比的情况如下：

<img  src="/img/crawler7/result3.jpg"/>

可以发现，请求的表单有

```
staticpage
charset
token
tpl
subpro
apiver
tt
codestring
safeflg
u
isPhone
detect
gid
quick_user
logintype
logLoginType
idc
loginmerge
splogin
username
password
verifycode
mem_pass
rsakey
crypttype
ppui_logintime
countrycode
fp_uid
dv
callback
```

其中，被红框框起来的表单是多次请求变化的：

```
callback
tt
token
ppui_logintime
rsakey
verifycode
```

其中很明显可以看出来的是:

>1. `tt` 时间戳
>2. `verifycode` 验证码

那么就剩下几个请求表单还暂时无法得知，首先查找 `callback`：

```
>1. 在 `firebug` 中勾选脚本，点击 `{}`
>2. 搜索中勾选 **多个文件**
>3. 在搜索框中搜索 `callback`
```

<img  src="/img/crawler7/result4.jpg"/>

一直搜索，最后发现 `callback` 和 `getUniqueId` 的生成有关：

<img  src="/img/crawler7/result5.jpg"/>

那么换着 `getUniqueId` 来搜索，得到如下 `javascrip` 代码：

```
e.getUniqueId = function (e) {
return e + Math.floor(2147483648 * Math.random()).toString(36)
},
```

和上面的 `JavaScrip` 整理起来，那么 `callback` 的生成代码为：

```
function callback(){
        return 'bd__cbs__'+Math.floor(2147483648 * Math.random()).toString(36)
    }
```

找到 `callback` 后，接下来要去寻找 `token` 。在 `firebug` 中寻找 `token` 第一次在哪里出现。最后发现首次出现在网址：

```
https://passport.baidu.com/v2/api/?getapi&tpl=mn&apiver=v3&tt=1495185331704&class=login&gid=63F95D8-F402-4128-A98B-C7D3C19B8F89&logintype=dialogLogin&callback=bd__cbs__3cagws
```

<img  src="/img/crawler7/result6.jpg"/>

这个网址返回的是一个 `Json` ：

```
bd__cbs__3cagws({"errInfo": {"no": "0"},
                 "data": {"rememberedUserName": "", "codeString": "", "token": "6245a75e6ba48d39033a8c31dfcb37c7",
                          "cookie": "1", "usernametype": "", "spLogin": "rate", "disable": "",
                          "loginrecord": {'email': [], 'phone': []}}})
```

第一次 `token` 出现的地方找到了，那么分析一下请求出 `token` 的网址，网址中涉及到的变量有：

```
tpl
apiver
tt
class
gid
logintype
callback
```

为了查看哪些变量是变化的，就再次进行多次登陆。最后发现，变化的是：

```
tt
gid
callback
```

其中 `tt` 为长时间戳， `callback` 在前面已经找到并且能生成了，那么只剩下 `gid` 这个变量。老规矩，按照下面的步骤再去找出 `gid` ：

>1. 在 `firebug` 中勾选脚本，点击 `{}`
>2. 搜索中勾选 **多个文件**
>3. 在搜索框中搜索 `gid`

搜索发现 `gid` 是由 `gid: e.guideRandom` 这个函数生成的：

<img  src="/img/crawler7/result7.jpg"/>

那么接着搜搜这个函数 `guideRandom` ，找到如下 `JavaScrip` 代码：

```
this.guideRandom = function () {
return 'xxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (e) {
var t = 16 * Math.random() | 0,
n = 'x' == e ? t : 3 & t | 8;
return n.toString(16)
}).toUpperCase()
}(),
```

整理一下让其可以在 `python` 中运行：

```
function gid(){
        return 'xxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (e) {
        var t = 16 * Math.random() | 0,
        n = 'x' == e ? t : 3 & t | 8;
        return n.toString(16)
        }).toUpperCase()
    }
```

这样，根据 `gid` 和 `callback` 就能得到 `token` 了！

下面继续寻找 `ppui_logintime` ，按照规矩来：

>1. 在 `firebug` 中勾选脚本，点击 `{}`
>2. 搜索中勾选 **多个文件**
>3. 在搜索框中搜索 `ppui_logintime` ，找到了 `timeSpan: 'ppui_logintime'` 

<img  src="/img/crawler7/result8.jpg"/>

接着搜索 `timeSpan` ，得到如下信息：

```
s.timeSpan = (new Date).getTime() - e.initTime
```

现在还是看不出什么东西，那么就继续搜索 `initTime` ，得到如下代码：

```
_initApi: function (e) {
var t = this;
t.initialized = !0,
t.initTime = (new Date).getTime(),
passport.data.getApiInfo({
apiType: 'login',
gid: t.guideRandom || '',
loginType: t.config && t.config.diaPassLogin ? 'dialogLogin' : 'basicLogin'
}).success(function (n) {
var i = t.fireEvent('getApiInfo', {
rsp: n
});
```

<img  src="/img/crawler7/result9.jpg"/>

继续查找 `initApi` ，找到位置：

<img  src="/img/crawler7/result10.jpg"/>

原来是在登陆的时候发生点击，内容改变，按键按下等事件的时候，会调用 `_initApi`，再看源码和 `ppui_logintime` 的数值可以发现， `ppui_logintime` 代表的是从输入信息开始到点击登陆后结束的时间差！那么在后面 `post` 的时候直接可以自己构造这个数据了。

那么最后还剩下一个变量 `rsakey` ，在查找网页的时候发现第一次出现 `rsakey` 的地方是：

```
https://passport.baidu.com/v2/getpublickey?token=fcd1f6684072372c6812a44c1d94bf51&tpl=mn&apiver=v3&tt=1461222170065&gid=C539A37-9B0C-4538-9920-E150AC6AE0D5&callback=bd__cbs__tpdrlq
```

也就是这里面的 `key` ，虽然名字不一样，但是值是一样的：

```
bd__cbs__tpdrlq({"errno": '0', "msg": '',
                 "pubkey": '-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDiA2HxDW2iVnunx7faCBG3YGBy\nvvF+ysFAIXIVjFTseU7x\/f+Gpr1VTWe2Kxc2dlzBkn5NuRHVxbyXCawu0QlMUfb8\nI2ukM1cIlL0e+B1nBnIp03oXjFvQNhIu58SI6vCoihWX6Qwhb6ZOvJdA249zCNBU\nlTyd7RVwgwaAthI6gQIDAQAB\n-----END PUBLIC KEY-----\n',
                 "key": 'wS27H0665CWXK64i2VP02AYtjQUTujkb'})
```

分析一下这个网址，出现的变量有：

```
token
tpl
apiver
tt
gid
callback
```

这些变量在前面都能找到，所以也就是说，根据 `gid` 、 `callback` 、 `token` 就能得到 `rsakey` 了！

最后还差一个变量 `codestring` ，在查找的过程中发现可以在这里面找到：

```
https://passport.baidu.com/v2/api/?logincheck&token=61ed8a353fa7e2a63cf8f94650ef2d47&tpl=mn&apiver=v3&tt=1495185970995&sub_source=leadsetpwd&username=灰色52056&isphone=false&dv=MDEwAAoAIwAKAkYAIQAAAF00AAwCAB_TmpqakyIqfj9xNmQlaDdoOGs7ZFwDXClaP00DYg9qDAIAH9Obm5uSPZfDgsyL2ZjVitWF1obZ4b7hlOeC8L7fstcIAgAJy8rExbu7shVcCQIADMvKeHhCQkJCS9zr6wcCAATLy8vLBwIABMvLy8sMAgAPw9HR0dUSfQljPFA_WDFfDQIABcvK_woKDQIABcvK58XFDQIABcvK5_v7DQIABcvLxjExDQIABcvLxigoBgIAKMvLy4yMjIyMjIyJBgYGBmNjY2bGxsbFQUFBROTk5Oe7u7u-Dg4ODWETAgAay93d3bXBtcW2jKOM-4z71bfWv9uugOOM4c4XAgAPyMl6enAtBD5YJUMsXnYABAIABsjIysv_zBUCAAjLy8qWiXTjGwECAAbLycnGzzAFAgAEy8vLwRYCACLqnvXF69ju2evd6tvq3-7b6N3l0eDR5dzp2ODV5tXn1eXSEAIAAcsHAgAEy8vLywgCAAnLy7m5nZ2ZAiMJAgAMy8rOzvv7-_vyovPzCAIAH93f09O3t74tTDxdLl0tQjBEaQVqDWQKJ1c4SGUEdB0HAgAEy8vLywgCAAnLyhsbU1NawGAJAgAk09GpqLCwsLC5FR0dSQhGAVMSXwBfD1wMU2s0ax5tCHo0VThdBwIABMvLy8sHAgAEy8vLywwCAB_ThoaGjz94LG0jZDZ3OmU6ajlpNg5RDnsIbR9RMF04BwIABMvLy8sMAgAf09vb29Jjit6f0ZbEhciXyJjLm8T8o_yJ-p_to8Kvyg&callback=bd__cbs__njimhi
```

所需要的变量为：

```
token
tpl
apiver
tt
sub_source
username
dv
callback
```

这些变量在前面都找到了，那么也能轻松的获取 `codestring` 了。

下面开始讲解怎么用 `python` 来实现模拟百度登陆！

### 获取callback

`callback` 是由 `JavaScrip` 生成的：

```
function callback(){
            return 'bd__cbs__'+Math.floor(2147483648 * Math.random()).toString(36)
        }
```

所以直接在 `python` 中运行这个 `JavaScrip` 就行了。 `python` 运行 `JavaScrip` 需要安装库 `pyexecjs`，在命令指示符下直接输入 `pip3 install pyexecjs` 即可。调用方式为：

```
import execjs
js = '''function callback(){
            return 'bd__cbs__'+Math.floor(2147483648 * Math.random()).toString(36)
        }
'''
ctx = execjs.compile(js)
callback = ctx.call("callback")
```

### 获取gid

`gid` 同样是可以用 `JavaScrip` 生成的，直接调用即可：

```
import execjs
js = '''function gid(){
            return 'xxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (e) {
            var t = 16 * Math.random() | 0,
            n = 'x' == e ? t : 3 & t | 8;
            return n.toString(16)
            }).toUpperCase()
        }'''
ctx = execjs.compile(js)
gid = ctx.call("gid")
```

### 获取时间tt

时间 `tt` 是一个毫秒级别的长时间，而 `python` 生成的时间戳是短时间，所以要在短时间戳后面加上毫秒的长度即可，这里处理的方法是：在短时间戳的后面加上 `3` 位数的随机数，从而构造出长时间戳。

```
import time
import random

timerandom = random.randint(100, 999)
nowtime = int(time.time())
tt = nowtime + timerandom
```

### 获取token

有了 `callback` 、 `gid` 、 `tt` 后，可以获取到 `token` ，构造网址：

```
token_url = "https://passport.baidu.com/v2/api/?getapi&tpl=mn&apiver=v3&tt=" + str(tt) + "&class=login&gid=" + gid + "&logintype=dialogLogin&callback=" + callback
```

设置一个请求网页的函数：

```
def gethtml(url):
    header = {'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:32.0) Gecko/20100101 Firefox/32.0',
              'Host': 'passport.baidu.com',
              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
              'Accept-Encoding': 'gzip, deflate',
              'Accept-Language': 'zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3',
              'Connection': 'keep-alive'}

    # 解析网页
    html_bytes = requests.get(url, headers=header)
    return html_bytes
```

代入 `token_url` ，得到的结果如下：

```
bd__cbs__mh9he9({"errInfo": {"no": "0"}, "data": {"rememberedUserName": "", "codeString": "",
                                                  "token": "the fisrt two args should be string type:0,1!",
                                                  "cookie": "0", "usernametype": "", "spLogin": "rate", "disable": "",
                                                  "loginrecord": {'email': [], 'phone': []}}})
```

生成的 `token_url` 为 `https://passport.baidu.com/v2/api/?getapi&tpl=mn&apiver=v3&tt=1495417537&class=login&gid=5DE4001-9842-4AF9-B134-3AFDEF399BE2&logintype=dialogLogin&callback=bd__cbs__mh9he9` ，但是返回来的 `token` 却是 `the fisrt two args should be string type:0,1!` ，这是什么鬼？？将得到的网址放到浏览器中，得到的结果为：

```
bd__cbs__mh9he9({"errInfo": {"no": "0"},
                 "data": {"rememberedUserName": "", "codeString": "", "token": "61ed8a353fa7e2a63cf8f94650ef2d47",
                          "cookie": "1", "usernametype": "", "spLogin": "rate", "disable": "",
                          "loginrecord": {'email': [], 'phone': []}}})
```

果断的 `F12` ，多次尝试后发现，返回 `the fisrt two args should be string type:0,1!` 的请求头部没有 `Cookie` ，返回正确的 `token` 的头部有 `Cookie` ：

```
Cookie:HOSUPPORT=1; BAIDUID=CB971A01EE47D8E817862FFB3630BBAD:FG=1
```

查找后发现，这个 `Cookie` 在第一次请求，也就是返回 `the fisrt two args should be string type:0,1!` 的时候，响应头信息里面的 `Set-Cookie` 有这些字段：

<img  src="/img/crawler7/result11.jpg"/>

将 `Set-Cookie` 中的值获取回来：

```
# 获取返回头部的set-cookie
def getset_cookie(response):
    return response.headers['set-cookie']
```

再写一个函数来解析 `Set-Cookie` 拿到我们想要的字段 `HOSUPPORT` 、 `BAIDUID` 、 `FG` ： 

```
# 解析set-cookie获得cookie的字典
def get_cookie(setcookie):
    dict = {}
    temparr = setcookie.split(" ")
    for item in temparr:
        if "HOSUPPORT" in item:
            dict["HOSUPPORT"] = item
        elif "FG" in item:
            for itm in item.split(":"):
                if "FG" in itm:
                    dict["FG"] = itm
                if "BAIDUID" in itm:
                    dict["BAIDUID"] = itm
    return dict
```

得到的结果为：

```
{'HOSUPPORT': 'HOSUPPORT=1;', 'BAIDUID': 'BAIDUID=8803BE70D6B77698B4C301F038C73694', 'FG': 'FG=1;'}
```

增加一个携带 `cookie` 抓取页面的头部：

```
# 携带cookie的get网页的函数
def gethtml_cookie(url, dict):
    header = {'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:32.0) Gecko/20100101 Firefox/32.0',
              'Host': 'passport.baidu.com',
              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
              'Accept-Encoding': 'gzip, deflate',
              'Accept-Language': 'zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3',
              'Cookie': dict["HOSUPPORT"] + "; " + dict["ASP.BAIDUID"] + "; " + dict["FG"],
              'Connection': 'keep-alive'}
```

顺利抓到包含 `token` 的返回值，再写一个正则解析这个返回值就能得到 `token` 了：

```
# 提取token的正则表达式
def get_token_re(token_response):
        reg = r'("token" : ")(.+?)(",)'
        all = re.compile(reg)
        alllist = re.findall(all, token_response)
        return alllist[0][1]
```

顺利返回 `token` ！

### 获取codeString

`codeString` 可以直接请求得到：

```
https://passport.baidu.com/v2/api/?logincheck&token=61ed8a353fa7e2a63cf8f94650ef2d47&tpl=mn&apiver=v3&tt=1495185970995&sub_source=leadsetpwd&username=灰色52056&isphone=false&dv=MDEwAAoAIwAKAkYAIQAAAF00AAwCAB_TmpqakyIqfj9xNmQlaDdoOGs7ZFwDXClaP00DYg9qDAIAH9Obm5uSPZfDgsyL2ZjVitWF1obZ4b7hlOeC8L7fstcIAgAJy8rExbu7shVcCQIADMvKeHhCQkJCS9zr6wcCAATLy8vLBwIABMvLy8sMAgAPw9HR0dUSfQljPFA_WDFfDQIABcvK_woKDQIABcvK58XFDQIABcvK5_v7DQIABcvLxjExDQIABcvLxigoBgIAKMvLy4yMjIyMjIyJBgYGBmNjY2bGxsbFQUFBROTk5Oe7u7u-Dg4ODWETAgAay93d3bXBtcW2jKOM-4z71bfWv9uugOOM4c4XAgAPyMl6enAtBD5YJUMsXnYABAIABsjIysv_zBUCAAjLy8qWiXTjGwECAAbLycnGzzAFAgAEy8vLwRYCACLqnvXF69ju2evd6tvq3-7b6N3l0eDR5dzp2ODV5tXn1eXSEAIAAcsHAgAEy8vLywgCAAnLy7m5nZ2ZAiMJAgAMy8rOzvv7-_vyovPzCAIAH93f09O3t74tTDxdLl0tQjBEaQVqDWQKJ1c4SGUEdB0HAgAEy8vLywgCAAnLyhsbU1NawGAJAgAk09GpqLCwsLC5FR0dSQhGAVMSXwBfD1wMU2s0ax5tCHo0VThdBwIABMvLy8sHAgAEy8vLywwCAB_ThoaGjz94LG0jZDZ3OmU6ajlpNg5RDnsIbR9RMF04BwIABMvLy8sMAgAf09vb29Jjit6f0ZbEhciXyJjLm8T8o_yJ-p_to8Kvyg&callback=bd__cbs__njimhi
```

构造网址：

```
codestring_url = "https://passport.baidu.com/v2/api/?logincheck&token=" + token + "&tpl=mn&apiver=v3&tt=" + str(tt) + "&sub_source=leadsetpwd&username=" + username + "&isphone=false&dv=" + dv + "&callback=" + callback
```

获得返回值：

```
bd__cbs__bsoe55({"errInfo": {"no": "0"}, "data": {"codeString": "njGf006f56cc1ebe2ee02fa14005b0121892605de068d041463",
                                                  "vcodetype": "00ba62vKTRp5fGN8NOJ2LdEY51rZpm1rYMRsM99WdZ1rrgBOZVgyhkREiSyxp4is2\/haSnHSovwU4kzfB93vhbhXv79YQGTlhDcR",
                                                  "userid": "", "mobile": ""}})
```

现在只需要写个正则提取出 `codeString` 就好：

```
# 提取codestring的正则表达式
def get_codestring_re(codestring_html):
    reg = r'("codeString" : ")(.+?)(",)'
    all = re.compile(reg)
    alllist = re.findall(all, codestring_html)
    return alllist[0][1]
```

### 获取rsakey

获取 `rsakey` 只需要构造如下网址即可：

```
raskey_url = "https://passport.baidu.com/v2/getpublickey?token=" + token + "&tpl=mn&apiver=v3&tt=" + str(tt) + "&gid=" + gid + "&callback=" + callback
```

在得到的返回值中使用正则提取出 `key` ，最后构造出来的 `postdata` 为：

```
# 构造postdata
postdata = {
    "apiver": "v3",
    "callback": callback,
    "charset": "UTF-8",
    "codestring": codestring,
    "countrycode": "",
    "crypttype": "12",
    "detect": "1",
    "dv": dv,
    "fp_uid": "8f29fdcf60e9b11186616c4baafa1509",
    "gid": gid,
    "idc": "",
    "isPhone": "",
    "logLoginType": "pc_loginDialog",
    "loginmerge": "true",
    "logintype": "dialogLogin",
    "mem_pass": "on",
    "password": password,
    "ppui_logintime": "26369",
    "quick_user": "0",
    "rsakey": rsakey,
    "safeflg": "0",
    "splogin": "rate",
    "staticpage": "https://www.baidu.com/cache/user/html/v3Jump.html",
    "subpro": "",
    "token": token,
    "tpl": "mn",
    "tt": tt,
    "u": "https://www.baidu.com/",
    "username": username,
    "verifycode": "成分"
}
```

可以看到最后只剩下 `verifycode` 验证码没有弄好，但是最后发现访问网址访问 `https://passport.baidu.com` 的时候不需要图片，所以用这个网址进行登陆：登陆是为了获取登陆成功后的所以用这个网址进行登陆：







<img  src="/img/crawler7/result6.jpg"/>

# 练习

```
增加百度翻页的效果，即可以选择抓取第2页、第3页等等
```

# 源码

<a href="/code/crawler6/crawler6.py" target="_blank">crawler6.py</a>

<a href="/code/crawler6/answer.py" target="_blank">练习答案</a>